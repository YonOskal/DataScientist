import numpy as np
from random import randint
# Задание 1. Гласные буквы
# Команде лингвистов понравилось качество ваших программ, поэтому они
# решили заказать функцию для анализатора текста, которая создавала бы
# список гласных букв в нём и считала бы их количество.
# Напишите программу, которая запрашивает у пользователя текст и генерирует
# список гласных букв этого материала (сама строка вводится на русском языке).
# Выведите в консоль сам список и его длину.
# Пример:
# Введите текст: Нужно отнести кольцо в Мордор!
# Список гласных букв: ['у', 'о', 'о', 'е', 'и', 'о', 'о', 'о', 'о']
# Длина списка: 9

# str = "Нужно отнести кольцо в Мордор!"
# gl = ["а", "у", "о", "ы", "э", "я", "ю", "ё", "и", "е", 
#       "А", "У", "О", "Ы", "Э", "Я", "Ю", "Ё", "И", "Е"]

# sp = [char for char in str if char in gl]

# print(len(sp))
# print(sp)


# Задача 2. Случайные соревнования
# Мы хотим протестировать работу электронной таблицы для участников
# некоторых соревнований. Есть два списка, то есть две команды, по 20
# участников в каждом. В них хранятся очки каждого участника — вещественные
# числа с двумя знаками после точки, например 4.03.
# Член одной команды соревнуется с участником другой команды под таким же
# номером. То есть первый соревнуется с первым, второй — со вторым и так
# далее.
# Напишите программу, которая генерирует два списка участников (по 20
# элементов) из случайных вещественных чисел (от 5 до 10). Для этого найдите
# подходящую функцию из модуля random. Затем сгенерируйте третий список, в
# котором окажутся только победители из каждой пары.
# Пример:
# Первая команда: [7.86, 6.76, 9.97, 9.08, 5.45, 6.9, 8.65, 5.17, 8.17, 5.06, 7.56, 7.1,
# 7.18, 8.25, 5.53, 7.95, 8.91, 7.11, 8.29, 9.52]
# Вторая команда: [7.13, 5.7, 8.89, 5.36, 5.62, 9.46, 5.82, 8.67, 8.41, 7.0, 5.31, 7.8,
# 9.93, 7.76, 7.4, 8.26, 7.94, 5.71, 7.89, 7.77]
# Победители тура: [7.86, 6.76, 9.97, 9.08, 5.62, 9.46, 8.65, 8.67, 8.41, 7.0, 7.56, 7.8,
# 9.93, 8.25, 7.4, 8.26, 8.91, 7.11, 8.29, 9.52]

# lst1 = []
# lst2 = []

# lst1 = np.random.uniform(5, 10, 20)
# lst2 = np.random.uniform(1, 10, 20)

# lst1 = np.round(lst1, 2)
# lst2 = np.round(lst2, 2)

# lst1 = lst1.tolist()
# lst2 = lst2.tolist()

# print("Первая команда", lst1)
# print("Вторая команда", lst2)

# print("Победители тура",[max(lst1[i], lst2[i]) for i in range(len(lst1))])

# Задача 3. Двумерный список
# Часто в программировании приходится писать код исходя из результата,
# который требует заказчик. В этот раз ему нужно получить двумерный список:
# [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
# Напишите программу, которая генерирует такой список и выводит его на экран.
# Используйте только list comprehensions.

# n = int(input("Введите количество вложенных списков: "))
# m = int(input("Введите количество элементов в списках: "))

# print([[randint(1, 10) for _ in range(n)] for _ in range(m)])


# lst1 = []
# for i in range(4):
#     row = []
#     for j in range(3):
#         row.append(randint(1, 10))  # Заполняем строку значениями
#     lst1.append(row)  # Добавляем строку в массив
# print(lst1)




# Задача 4. Список списков
# Дан многомерный список:
# nice_list = [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 11, 12], [13, 14, 15], [16, 17, 18]]]
# Напишите код, который раскрывает все вложенные списки, то есть оставляет
# лишь внешний список. Для решения используйте только list comprehensions.
# Ответ: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]

nice_list = [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 11, 12], [13, 14, 15], [16, 17, 18]]]

print([num for sublist in nice_list for inner_list in sublist for num in inner_list])

# Да, приведенный пример предполагает, что мы знаем глубину вложенности списка. 
# Если глубина списка неизвестна и может варьироваться, можно использовать рекурсивный подход для "распаковки" вложенных списков. Вот пример:

def flatten(nested_list):
    flattened_list = []
    for item in nested_list:
        if isinstance(item, list):
            flattened_list.extend(flatten(item))  # Рекурсивный вызов
        else:
            flattened_list.append(item)
    return flattened_list

nice_list = [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 11, 12], [13, 14, 15], [16, 17, 18]]]
result = flatten(nice_list)

print(result)


# В этом коде функция flatten проверяет каждый элемент. Если элемент — это список, она вызывает саму себя рекурсивно. 
# Если элемент не является списком, он добавляется в результирующий список. Это позволяет обрабатывать вложенные списки любой глубины.